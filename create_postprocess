#!/usr/bin/env python
"""Read the necessary xml files from the postprocessing configuration system and translate
them into bash scripts for batch submission of postprocessing tasks. 

Arguments:
caseroot (mandatory) - full path to a valid CESM case

Creates files: 
$CASEROOT/env_postprocess.xml
$CASEROOT/env_timeseries.xml
$CASEROOT/env_diags_atm.xml
$CASEROOT/env_diags_ice.xml
$CASEROOT/env_diags_lnd.xml
$CASEROOT/env_diags_ocn.xml
$CASEROOT/$CASENAME.timeseries
$CASEROOT/$CASENAME.$COMP_averages
$CASEROOT/$CASENAME.$COMP_diagnostics
__________________________
Created on April, 2015

Author: CSEG <cseg@cgd.ucar.edu>
"""

from __future__ import print_function

import sys

# check the system python version and require 2.7.x or greater
if sys.hexversion < 0x02070000:
    print(70 * "*")
    print("ERROR: {0} requires python >= 2.7.x. ".format(sys.argv[0]))
    print("It appears that you are running python {0}".format(
            ".".join(str(x) for x in sys.version_info[0:3])))
    print(70 * "*")
    sys.exit(1)

#
# built-in modules
#
import argparse
import collections
import os
import platform
import pprint
import re
import shutil
import subprocess
import traceback


#
# installed dependencies
#
try:
    import lxml.etree as etree
except:
    import xml.etree.ElementTree as etree

if sys.version_info[0] == 2:
    from ConfigParser import SafeConfigParser as config_parser
else:
    from configparser import ConfigParser as config_parser

#
# activate the virtual environment that was created by create_python_env.sh
#
if ( not os.path.isfile('./cesm-env2/bin/activate_this.py') ):
    err_msg = ('create_postprocess ERROR: the virtual environment cesm-env2 does not exist.' \
               'Please run $POSTPROCESSING_DIR/create_python_env.sh [-machine_dir [machine directory]] -machine [machine name]')
    raise OSError(err_msg)

execfile('./cesm-env2/bin/activate_this.py', dict(__file__='./cesm-env2/bin/activate_this.py'))

#
# import modules installed in the virtual environment
#
from cesm_utils import cesmEnvLib
import jinja2

# -------------------------------------------------------------------------------
# define a class to be used for the xml entry, id, desc values
# -------------------------------------------------------------------------------
class XmlEntry(object):
    def __init__(self, id, value, desc):
        self._id = id
        self._value = value
        self._desc = desc
    
    def id(self):
        return self._id
    
    def value(self):
        return self._value

    def desc(self):
        return self._desc


# -------------------------------------------------------------------------------
# check_standalone - read the env_postprocess.xml, if it exists, and check for
# the STANDALONE xml entry
# -------------------------------------------------------------------------------
def check_standalone(caseroot):
    """read the env_postprocess.xml, if it exists, and check for
    the STANDALONE xml entry
    
    Arguments:
    caseroot (string) - caseroot directory path
    
    Returns:
    standalone (boolean) - indicate if caseroot is standalone or not
    """

    configFile = '{0}/env_postprocess.xml'.format(caseroot)
    rc, err_msg = cesmEnvLib.checkFile(configFile, 'read')
    standalone = False

    if rc:
        xml_tree = etree.ElementTree()
        xml_tree.parse(configFile)
        for entry_tag in xml_tree.findall('entry'):
            if (entry_tag.get('id') == 'STANDALONE' and entry_tag.get('value').lower() == 'true'):
                standalone = True

    return standalone

# -------------------------------------------------------------------------------
# commandline_options - parse any command line options
# -------------------------------------------------------------------------------

def commandline_options():
    """Process the command line arguments.

    """
    parser = argparse.ArgumentParser(
        description='Read the necessary xml files from the postprocessing configuration system and translate them into bash scripts for batch submission of postprocessing tasks. Runtime options can be set in the env_*.xml files in the caseroot.')

    parser.add_argument('--backtrace', action='store_true',
                        help='show exception backtraces as extra debugging '
                        'output')

    parser.add_argument('--debug', nargs=1, required=False, type=int, default=0,
                        help='debugging verbosity level output: 0 = none, 1 = minimum, 2 = maximum. 0 is default')

    parser.add_argument('--caseroot', nargs=1, required=True, 
                        help='fully quailfied path to case root directory')

    parser.add_argument('--machine', nargs=1, required=False, default=None,
                        help='supported machine name is required when creating a caseroot that does not already exist')

    options = parser.parse_args()

# TODO check the machine...

    # check to make sure CASEROOT is a valid, readable directory
    standalone = False
    if not os.path.isdir(options.caseroot[0]):
        create_caseroot = raw_input('create_postprocess WARNING: caseroot {0} does not exist. Would like to create it for post processing purposes (Y/N)? '.format(options.caseroot[0]))
        if 'y' in create_caseroot.lower():
            if options.machine is None:
                print('create_postprocess ERROR: cannot create a new caseroot without also specifying a supported machine. Exiting...')
                sys.exit(1)
            try:
                os.mkdir(options.caseroot[0])
                standalone = True
            except:
                raise OSError('create_postprocess ERROR: cannot create a new caseroot. Exiting...')
    # check if this is a standalone case that has already been created
    else:
        # read the env_postprocess.xml, if it exists, and check for STANDALONE flag
        standalone = check_standalone(options.caseroot[0])
        if (standalone):
            if options.machine is None:
                print('create_postprocess ERROR: cannot create a new caseroot without also specifying a supported machine. Exiting...')
                sys.exit(1)
        
    return options, standalone


# -------------------------------------------------------------------------------
# create_env_file - generate the env_[file].xml 
# -------------------------------------------------------------------------------
def create_env_file(envDict, configFile, tmplFile, envFile, group, obs_root, standalone):
    """create the env_[file].xml file in the CASEROOT
    
    Arguments:
    envDict (dictionary) - environment dictionary
    configFile (string) - full path to input config_[definition].xml file
    tmplFile (string) - template file for output env_[file].xml
    envFile (string) - output env_[file].xml name
    group (string) - group designation read from XML file
    obs_root (string) - observation data file root directory
    standalone (boolean) - indicate if this is postprocessing for a standalone case
    
    Returns:
    envDict (dictionary) - environment dictionary
    """
    xml_list = []
    rc, err_msg = cesmEnvLib.checkFile(configFile, 'read')
    rc1, err_msg1 = cesmEnvLib.checkFile('{0}/Templates/{1}'.format(envDict['POSTPROCESS_DIR'], tmplFile), 'read')

    if rc:
        xml_tree = etree.ElementTree()
        #print ('creating configFile = {0}'.format(configFile))
        xml_tree.parse(configFile)
        for entry_tag in xml_tree.findall('entry'):
            if entry_tag.get('group').lower() == group:
                xml_list.append(XmlEntry(entry_tag.get('id'), entry_tag.get('value'), entry_tag.get('desc')))

        # add an additional entry for machine dependent input observation files root path
        if obs_root:
            if len(obs_root) > 0:
                xml_obs = XmlEntry('DIAGOBSROOT', obs_root, 'Diagnostics observation files root path')
                xml_list.append(xml_obs)
        
        # the xml_list now contains a list of XmlEntry classes that can be written to the template
        templateLoader = jinja2.FileSystemLoader( searchpath='{0}/Templates'.format(envDict['POSTPROCESS_DIR']) )
        templateEnv = jinja2.Environment( loader=templateLoader )
        if rc1:
            template = templateEnv.get_template( tmplFile )
            templateVars = { 'caseroot' : envDict['CASEROOT'],
                             'case' : envDict['CASE'],
                             'postprocess_dir' : envDict['POSTPROCESS_DIR'],
                             'xml_list' : xml_list,
                             'standalone' : standalone }
        
            # render the template
            env_tmpl = template.render( templateVars )

            # write the env_file
            with open( envFile, 'w') as xml:
                xml.write(env_tmpl)
        else:
            raise OSError(err_msg)
    else:
        raise OSError(err_msg)

# -------------------------------------------------------------------------------
# read_machine_xml
# -------------------------------------------------------------------------------
def read_machine_xml(machineName, xmlFile):
    """ read_machine_xml - read the xmlFile with specified machine pe 
    counts for postprocessing tasks.

    Arguments:
    machine (string) - machine name
    xmlFile (string) - XML file containing machine pe layout for postprocessing

    Return:
    peDict (dictionary) - PE count for each postprocess task
    """
    xmlDict = dict()
    xmlDict['modules'] = []
    found = False
    rc, err_msg = cesmEnvLib.checkFile(xmlFile, 'read')
    if rc:
        xml_tree = etree.ElementTree()
        xml_tree.parse(xmlFile)

        # find the matching machine name
        for xmlmachine in xml_tree.findall("machine"):
            if machineName.lower() == xmlmachine.get("name").lower():

                found = True
                # get the timeseries pes first
                xmlDict['timeseries_pes'] = xmlmachine.find('timeseries_pes').text

                # get the mpi run command
                xmlDict['mpi_command'] = xmlmachine.find('mpi_command').text

                # get the pythonpath command
                xmlDict['pythonpath'] = xmlmachine.find('pythonpath').text
                if xmlDict['pythonpath'] is None:
                    xmlDict['pythonpath'] = ''

                # get the project
                xmlDict['project'] = xmlmachine.find('project').text

                # loop through the module list
                for mod in xmlmachine.findall("modules/module"):
                    xmlDict['modules'].append(mod.text)

                # loop through the compList to get the component PE layouts
                # and observation data root
                for comp in xmlmachine.findall("components/component"):
                    compName = comp.get("name").lower()
                    xmlDict['{0}_averages_pes'.format(compName)] = comp.find('averages_pes').text
                    xmlDict['{0}_diagnostics_pes'.format(compName)] = comp.find('diagnostics_pes').text
                    xmlDict['{0}_obs_root'.format(compName)] = comp.find('obs_root').text

        if not found:
            err_msg = ('create_postprocess ERROR: Invalid machine "{0}" requested for postprocessing'.format(machine))
            raise OSError(err_msg)
    else:
        raise OSError(err_msg)

    return xmlDict

# -------------------------------------------------------------------------------
# create_batch - create the batch files for post processing submission
# -------------------------------------------------------------------------------
def create_batch(ppDir, pes, batchTmpl, runTmpl, postProcessCmd, mpiCmd, outFile, processName, project, pythonpath, caseRoot, modules, options, standalone):
    """create the batch submission files for post processing

    Arguments:
    ppDir (string) - postprocessing directory
    pes (integer) - number or PEs for post processing 
    batchTmpl (string) - machine dependent batch template file name 
    runTmpl (string) - run script template file 
    postProcessCmd (string) - post process command
    mpiCmd (string) - mpi run command
    outFile (string) - full path to output file for batch script
    processName (string) - post processing name for batch submission
    project (string) - project account number
    caseRoot (string) - case root directory path
    options (object) - commandline options
    standalone (boolean) - indicate if this is postprocessing for a standalone case
    """
    # first check if outFile already exists, if so delete and recreate
    rc, err_msg = cesmEnvLib.checkFile(outFile, 'read')
    if rc:
        os.unlink(outFile)

    # check if template files exist and are readable
    rc, err_msg = cesmEnvLib.checkFile('{0}/Templates/{1}'.format(ppDir, batchTmpl), 'read')
    if not rc:
        raise OSError(err_msg)

    rc, err_msg = cesmEnvLib.checkFile('{0}/Templates/{1}'.format(ppDir, runTmpl), 'read')
    if not rc:
        raise OSError(err_msg)

    virtualEnvDir = '{0}/cesm-env2/bin'.format(ppDir)
    # check that the postProcessCmd exists in the virtualenv
    rc, err_msg = cesmEnvLib.checkFile('{0}/{1}'.format(virtualEnvDir, postProcessCmd), 'read')
    if not rc:
        raise OSError(err_msg)

    debug = '--debug 0'
    if options.debug:
        debug = '--debug {0}'.format(options.debug[0])

    backtrace = ''
    if options.backtrace:
        backtrace = '--backtrace'

    # all files look good so start parsing the template file starting with the batchTmpl
    templateLoader = jinja2.FileSystemLoader( searchpath='{0}/Templates'.format(ppDir) )
    templateEnv = jinja2.Environment( loader=templateLoader )
    template = templateEnv.get_template( batchTmpl )
    templateVars = { 'pes' : pes,
                     'processName' : processName,
                     'project' : project }
        
    # render this template into the batchdirectives string
    batchdirectives = template.render( templateVars )

    # get the postprocessing run template 
    template = templateEnv.get_template( runTmpl )
    templateVars = { 'batchdirectives' : batchdirectives,
                     'modules' : modules,
                     'pes' : pes,
                     'mpirun' : mpiCmd,
                     'pythonpath': pythonpath,
                     'processName' : processName,
                     'postProcessCmd' : postProcessCmd,
                     'caseRoot' : caseRoot,
                     'virtualEnvDir' : virtualEnvDir,
                     'debug' : debug,
                     'backtrace' : backtrace,
                     'standalone' : standalone }

    # render this template into the runScript string
    runScript = template.render( templateVars )

    # write the runScript to the outFile
    with open( outFile, 'w') as fh:
        fh.write(runScript)

    # make runScript permission executable
    try:
        subprocess.check_call( ['chmod', '+x', outFile ] )
    except subprocess.CalledProcessError as e:
        print('create_postprocess: {0} could not be made executable'.format(outFile))
        print('WARNING: manually add execute permission to {0}'.format(outFile))
        print('    {0} - {1}'.format(e.cmd, e.output))


# -------------------------------------------------------------------------------
# initialize_main - initialization from main
# -------------------------------------------------------------------------------
def initialize_main(envDict, options, standalone):
    """initialize_main - initialize main settings
    
    Arguments:
    options (list) - input options from command line
    envDict (dictionary) - environment dictionary
    standalone (boolean) - indicate if this is postprocessing for a standalone case

    Return:
    envDict (dictionary) - environment dictionary
    """
    # CASEROOT is given on the command line as required option --caseroot
    caseroot = options.caseroot[0]

    if not standalone:
        # envDict['id'] = 'value' parsed from the CASEROOT/[env_file_list] files
        env_file_list = ['env_case.xml', 'env_run.xml', 'env_build.xml', 'env_mach_pes.xml']
        envDict = cesmEnvLib.readXML(caseroot, env_file_list)
    else:
        caseList = caseroot.split('/')
        envDict['CASE'] = caseList[-1]
        envDict['MACH'] = options.machine[0]

    # refer to the caseroot that was specified on the command line instead of what
    # is read in the environment as the caseroot may have changed from what is listed
    # in the env xml
    envDict['CASEROOT'] = caseroot

    return envDict

# -------------------------------------------------------------------------------
# main
# -------------------------------------------------------------------------------
def main(options, standalone):
    """ main

    Arguments:
    options (list) - input options from command line
    standalone (boolean) - indicate if this is postprocessing for a standalone case
    """
    # initialize the environment dictionary
    envDict = dict()
    envDict = initialize_main(envDict, options, standalone)

    # set the postprocessing dir in the envDict
    envDict['POSTPROCESS_DIR'] = os.getcwd()

    # TODO - needs to check the compset to see what is active 
    # and return the compList accordingly

    # set the list of components
##    complist = ['atm','ice','lnd','ocn']
    compList = ['ocn','atm','ice']

    # get the machine dependent variables, modules and mpi run command in a dictionary
    machine = dict()
    machine = read_machine_xml(envDict['MACH'], '{0}/Machines/machine_postprocess.xml'.format(envDict['POSTPROCESS_DIR']))

    # generate the env_postprocess.xml file
    config_file = '{0}/Config/config_postprocess.xml'.format(envDict['POSTPROCESS_DIR'])
    tmpl_file = 'env_postprocess.tmpl'
    env_file = '{0}/env_postprocess.xml'.format(envDict['CASEROOT'])
    create_env_file(envDict, config_file, tmpl_file, env_file, 'postprocess', '', standalone)

    # generate the env_timeseries.xml file
    config_file = '{0}/Config/config_timeseries.xml'.format(envDict['POSTPROCESS_DIR'])
    env_file = '{0}/env_timeseries.xml'.format(envDict['CASEROOT'])
    shutil.copy2(config_file, env_file)

    # generate the env_diags_[component].xml files
    for comp in compList:
        config_file = '{0}/diagnostics/diagnostics/{1}/Config/config_diags_{1}.xml'.format(envDict['POSTPROCESS_DIR'], comp)
        tmpl_file = 'env_diags.tmpl'
        env_file = '{0}/env_diags_{1}.xml'.format(envDict['CASEROOT'], comp)
        create_env_file(envDict, config_file, tmpl_file, env_file, 'diags_{0}'.format(comp), machine['{0}_obs_root'.format(comp)], standalone)

    # define the template files for the batch scripts
    batch_tmpl = 'batch_{0}.tmpl'.format(envDict['MACH'])
    run_tmpl = 'postprocess.tmpl'

    # generate the timeseries batch submit script from template files
    postProcessCmd = 'cesm_tseries_generator.py'
    outFile = '{0}/{1}.timeseries'.format(envDict['CASEROOT'], envDict['CASE'])
    processName = '{0}.timeseries'.format(envDict['CASE'])
    create_batch(envDict['POSTPROCESS_DIR'], machine['timeseries_pes'], batch_tmpl, run_tmpl, postProcessCmd, 
                 machine['mpi_command'], outFile, processName, machine['project'], machine['pythonpath'], 
                 envDict['CASEROOT'], machine['modules'], options, standalone)

    # generate the diagnostics batch submit scripts from template files
    for comp in compList:
        # generate the averages batch submit script
        postProcessCmd = '{0}_avg_generator.py'.format(comp)
        outFile = '{0}/{1}.{2}_averages'.format(envDict['CASEROOT'], envDict['CASE'], comp)
        processName = '{0}.{1}_averages'.format(envDict['CASE'], comp)
        create_batch(envDict['POSTPROCESS_DIR'], machine['{0}_averages_pes'.format(comp)], batch_tmpl, run_tmpl, postProcessCmd, 
                     machine['mpi_command'], outFile, processName, machine['project'], machine['pythonpath'], 
                     envDict['CASEROOT'], machine['modules'], options, standalone)

        # generate the diagnostics batch submit script
        postProcessCmd = '{0}_diags_generator.py'.format(comp)
        outFile = '{0}/{1}.{2}_diagnostics'.format(envDict['CASEROOT'], envDict['CASE'], comp)
        processName = '{0}.{1}_diagnostics'.format(envDict['CASE'], comp)
        create_batch(envDict['POSTPROCESS_DIR'], machine['{0}_diagnostics_pes'.format(comp)], batch_tmpl, run_tmpl, postProcessCmd, 
                     machine['mpi_command'], outFile, processName, machine['project'], machine['pythonpath'], 
                     envDict['CASEROOT'], machine['modules'], options, standalone)

    print('*****************************************************************************************')
    print('')
    print(' The CASEROOT {0}'.format(envDict['CASEROOT']))
    print(' now contains all the necessary post-processing submit scripts and associated')
    print(' XML configuration files. Please review the on-line documentation at')
    print(' http://www2.cesm.ucar.edu for a complete description of how')
    print(' to configure and use the CESM post-processing tools.')
    if standalone:
        print(' NOTICE: The postprocessing xml files in the new CASEROOT will need to be adjusted.')
    print('')
    print('*****************************************************************************************')
    
    
#===================================

if __name__ == "__main__":
    options, standalone = commandline_options()
    try:
        status = main(options, standalone)
        sys.exit(status)
    except Exception as error:
        print(str(error))
        if options.backtrace:
            traceback.print_exc()
        sys.exit(1)
